import React, { Component } from 'react';
import PropTypes from 'prop-types';
import electron, { remote } from 'electron';
import isEqual from 'lodash.isequal';
import os from 'os';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var toArray = function (arr) {
  return Array.isArray(arr) ? arr : Array.from(arr);
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var darkTheme = {
  /* Title */
  barTheme: 'dark', // light, dark
  barHeight: '22px', // Change this value if you set 'titleBarStyle' to 'hiddenInset'
  winBarHeight: '28px',
  barColor: '#fff',
  barTitleColor: 'inherit',
  barBackgroundColor: '#24292e',
  barShowBorder: false,
  titleFontFamily: 'inherit',
  titleFontWeight: 'normal',
  barBorderBottom: '1px solid #000',
  // should the icon be shown in the center of the toolbar on Mac/Linux apps alongside the app or title property
  showIconDarLin: true,

  /* Menu */
  menuStyle: 'horizontal', // horizontal, vertical
  menuDimItems: true,
  menuDimOpacity: 0.6,
  menuDisabledOpacity: 0.3,
  menuWidth: 240,
  menuBackgroundColor: '#fff',
  menuItemTextColor: '#fff',
  menuItemHoverBackground: 'rgba(255,255,255,0.3)',
  menuActiveTextColor: '#24292e',
  menuTextHighlightColor: '#fff',
  menuHighlightColor: '#0372ef',
  accentStatusIcon: true,
  menuSubLabelHeaders: true,
  menuSubLabelColor: '#6a737d',
  menuAcceleratorColor: '#6a737d',
  menuShowBoxShadow: true,
  menuBoxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
  /* Menu Overlay */
  menuOverlayBackground: 'black',
  menuOverlayOpacity: 0.4,
  menuSeparatorColor: '#e1e4e8',

  /* WindowControls */
  windowControlsColor: '#fff',
  windowCloseHover: '#fff',
  windowCloseBackground: '#e81123',
  windowCloseActive: '#bf0f1d',
  windowDefaultBackground: 'rgba(255,255,255,0.3)',
  windowDefaultActive: 'rgba(255,255,255,0.2)'
};

var lightTheme = _extends({}, darkTheme, {
  /* Title */
  barTheme: 'light',
  barColor: '#24292e',
  barBackgroundColor: '#e8e8e8',
  barBorderBottom: '1px solid #d3d4d5',

  /* Menu */
  menuItemTextColor: '#24292e',
  menuItemHoverBackground: 'rgba(0, 0, 0, 0.1)',

  /* WindowControls */
  windowControlsColor: '#000',
  windowDefaultBackground: 'rgba(0, 0, 0, 0.1)',
  windowDefaultActive: 'rgba(0, 0, 0, 0.2)'
});

var ThemeContext = React.createContext(darkTheme);

var ThemeConsumer = ThemeContext.Consumer;

var ThemeProvider = ThemeContext.Provider;

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css = ".styles_MenuButton__1URAL svg {\n  fill: currentColor;\n  width: 20px;\n  height: 20px;\n}\n\n.styles_MenuButton__1URAL:focus:not(.styles_focus-ring__Ie2g4) {\n  outline: none;\n}\n";
var css$1 = { "MenuButton": "styles_MenuButton__1URAL", "focus-ring": "styles_focus-ring__Ie2g4" };
styleInject(css);

var styles = {
  Wrapper: {
    minWidth: 0
  },
  ButtonWrapper: {
    width: '100%',
    height: '100%'
  },
  Button: {
    WebkitAppearance: 'none',
    border: 'none',
    boxShadow: 'none',
    background: 'transparent',
    borderRadius: 0,
    textAlign: 'left',
    margin: 0,
    padding: 0,
    height: '100%',
    width: '100%',
    fontSize: 12,
    paddingLeft: 10,
    paddingRight: 10
  }
};

var MenuButton = function (_Component) {
  inherits(MenuButton, _Component);

  function MenuButton() {
    classCallCheck(this, MenuButton);
    return possibleConstructorReturn(this, (MenuButton.__proto__ || Object.getPrototypeOf(MenuButton)).apply(this, arguments));
  }

  createClass(MenuButton, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          onMouseEnter = _props.onMouseEnter,
          onMouseLeave = _props.onMouseLeave,
          onMouseOver = _props.onMouseOver,
          onMouseMove = _props.onMouseMove,
          onTouchStart = _props.onTouchStart,
          onFocus = _props.onFocus,
          onClick = _props.onClick,
          label = _props.label,
          open = _props.open,
          enabled = _props.enabled,
          hovering = _props.hovering,
          rectRef = _props.rectRef;


      var theme = this.context;
      var backgroundColor = open ? theme.menuBackgroundColor : hovering && enabled ? theme.menuItemHoverBackground : 'transparent';
      var borderColor = open ? theme.menuBackgroundColor : '';
      var color = open ? theme.menuActiveTextColor : theme.menuItemTextColor;
      var opacity = enabled ? open || hovering || !theme.menuDimItems ? 1 : theme.menuDimOpacity : theme.menuDisabledOpacity;

      return React.createElement(
        'div',
        {
          style: styles.Wrapper,
          onMouseEnter: onMouseEnter,
          onMouseLeave: onMouseLeave,
          onMouseOver: onMouseOver,
          onMouseMove: onMouseMove,
          onTouchStart: onTouchStart,
          onFocus: onFocus,
          onClick: onClick,
          ref: rectRef
        },
        this.props.children,
        React.createElement(
          'div',
          {
            style: styles.ButtonWrapper
          },
          React.createElement(
            'button',
            {
              className: css$1.MenuButton,
              style: _extends({}, styles.Button, {
                backgroundColor: backgroundColor,
                borderColor: borderColor,
                color: color
              }),
              tabIndex: '-1'
            },
            React.createElement(
              'div',
              {
                style: {
                  opacity: opacity
                }
              },
              React.createElement(
                'span',
                { 'aria-hidden': 'true' },
                label
              )
            )
          )
        )
      );
    }
  }]);
  return MenuButton;
}(Component);


MenuButton.propTypes = {
  children: PropTypes.node,
  enabled: PropTypes.bool,
  label: PropTypes.oneOfType([PropTypes.string, PropTypes.node]).isRequired,
  open: PropTypes.bool,
  closed: PropTypes.bool,
  hovering: PropTypes.bool,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  onMouseOver: PropTypes.func,
  onMouseMove: PropTypes.func,
  onTouchStart: PropTypes.func,
  onFocus: PropTypes.func,
  onClick: PropTypes.func,
  rectRef: PropTypes.func
};

MenuButton.contextType = ThemeContext;

MenuButton.defaultProps = {
  open: false,
  closed: false,
  hovering: false,
  enabled: true,
  onMouseEnter: function onMouseEnter() {},
  onMouseLeave: function onMouseLeave() {},
  onMouseOver: function onMouseOver() {},
  onMouseMove: function onMouseMove() {},
  onTouchStart: function onTouchStart() {},
  onFocus: function onFocus() {},
  onClick: function onClick() {},
  rectRef: function rectRef() {}
};

var css$2 = ".styles_StatusIcon__36XEE {\n  width: 12px;\n  height: 12px;\n  flex-shrink: 0;\n}\n\n.styles_StatusIcon__36XEE svg {\n  width: 100%;\n  height: 100%;\n  fill: currentColor;\n}\n\n.styles_SubMenuArrow__1fsxq {\n  flex-shrink: 0;\n  opacity: 0.7;\n  height: 24px;\n  color: inherit;\n}\n\n.styles_SubMenuArrow__1fsxq svg {\n  fill: currentColor;\n}";
var css$3 = { "StatusIcon": "styles_StatusIcon__36XEE", "SubMenuArrow": "styles_SubMenuArrow__1fsxq" };
styleInject(css$2);

var checked = React.createElement(
  'svg',
  { width: '1792', height: '1792', viewBox: '0 0 1792 1792', xmlns: 'http://www.w3.org/2000/svg' },
  React.createElement('path', { d: 'M1671 566q0 40-28 68l-724 724-136 136q-28 28-68 28t-68-28l-136-136-362-362q-28-28-28-68t28-68l136-136q28-28 68-28t68 28l294 295 656-657q28-28 68-28t68 28l136 136q28 28 28 68z' })
);
var unchecked = React.createElement('span', null);
var radioUnchecked = React.createElement(
  'svg',
  { width: '1792', height: '1792', viewBox: '0 0 1792 1792', xmlns: 'http://www.w3.org/2000/svg' },
  React.createElement('path', { d: 'M896 352q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73 198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z' })
);
var radioChecked = React.createElement(
  'svg',
  { width: '1792', height: '1792', viewBox: '0 0 1792 1792', xmlns: 'http://www.w3.org/2000/svg' },
  React.createElement('path', { d: 'M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75 75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73 198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z' })
);
var arrow = React.createElement(
  'svg',
  { version: '1.1', width: '24px', height: '24px' },
  React.createElement(
    'g',
    { id: 'Rounded' },
    React.createElement('path', { d: 'M9.29,6.71L9.29,6.71c-0.39,0.39-0.39,1.02,0,1.41L13.17,12l-3.88,3.88c-0.39,0.39-0.39,1.02,0,1.41l0,0c0.39,0.39,1.02,0.39,1.41,0l4.59-4.59c0.39-0.39,0.39-1.02,0-1.41l-4.59-4.59C10.32,6.32,9.68,6.32,9.29,6.71z' })
  )
);

var styles$1 = {
  Wrapper: {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    minWidth: 0,
    fontSize: 12,
    padding: '0px 10px',
    height: 30,
    color: 'inherit',
    cursor: 'default'
  },
  Label: {
    flexGrow: 1,
    marginLeft: 10,
    marginRight: 10,
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
  },
  Accelerator: {
    flexShrink: 0,
    marginRight: 10
  },
  Separator: {
    display: 'block',
    width: '100%',
    border: 'none',
    height: 1
  },
  Icon: {
    width: '100%',
    height: '100%',
    backgroundSize: 'contain',
    backgroundPosition: 'center'
  }
};

var MenuItem = function (_Component) {
  inherits(MenuItem, _Component);

  function MenuItem(props) {
    classCallCheck(this, MenuItem);

    var _this = possibleConstructorReturn(this, (MenuItem.__proto__ || Object.getPrototypeOf(MenuItem)).call(this, props));

    _this.state = {
      hovering: false
    };
    _this.handleMouseEnter = _this.handleMouseEnter.bind(_this);
    _this.handleMouseLeave = _this.handleMouseLeave.bind(_this);
    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  createClass(MenuItem, [{
    key: 'handleMouseEnter',
    value: function handleMouseEnter(e) {
      var menuItem = this.props.menuItem;


      if (menuItem.enabled === false) {
        e.stopPropagation();
        return;
      }

      this.setState({
        hovering: true
      });
    }
  }, {
    key: 'handleMouseLeave',
    value: function handleMouseLeave(e) {
      var menuItem = this.props.menuItem;


      if (menuItem.enabled === false) {
        e.stopPropagation();
        return;
      }

      this.setState({
        hovering: false
      });
    }
  }, {
    key: 'handleClick',
    value: function handleClick(e) {
      var _props = this.props,
          menuItem = _props.menuItem,
          changeCheckState = _props.changeCheckState,
          path = _props.path,
          indx = _props.indx;


      if (menuItem.enabled === false) {
        e.stopPropagation();
        return;
      }

      switch (menuItem.type) {
        case 'checkbox':
          {
            e.persist();
            var newMenuItem = _extends({}, menuItem, {
              checked: !menuItem.checked
            });
            menuItem.click(newMenuItem, remote.getCurrentWindow(), e);
            // TODO: Change Checked State
            changeCheckState(path, indx, !menuItem.checked);
            break;
          }
        case 'radio':
          {
            // e.persist();
            var _newMenuItem = _extends({}, menuItem, {
              checked: true
            });
            menuItem.click(_newMenuItem, remote.getCurrentWindow(), e);
            if (!menuItem.checked) {
              // TODO: Change Checked State
              changeCheckState(path, indx, true, true);
            }
            break;
          }
        default:
          e.persist();
          menuItem.click(this.props.menuItem, remote.getCurrentWindow(), e);
          break;
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          children = _props2.children,
          menuItem = _props2.menuItem;
      var hovering = this.state.hovering;


      var theme = this.context;

      var isSubMenu = menuItem.type && menuItem.type.toLowerCase() === 'submenu';

      if (menuItem.visible === false) {
        return null;
      }

      if (menuItem.type && menuItem.type.toLowerCase() === 'separator') {
        return React.createElement('hr', {
          style: _extends({}, styles$1.Separator, {
            borderBottom: '1px solid ' + theme.menuSeparatorColor
          })
        });
      }

      var statusIcon = React.createElement('span', null);

      if (menuItem.type === 'radio') {
        statusIcon = menuItem.checked ? radioChecked : radioUnchecked;
      } else if (menuItem.type === 'checkbox') {
        statusIcon = menuItem.checked ? checked : unchecked;
      } else if (menuItem.icon) {
        statusIcon = React.createElement('div', {
          style: _extends({}, styles$1.Icon, {
            backgroundImage: 'url(' + menuItem.icon + ')'
          })
        });
      }

      return React.createElement(
        'div',
        {
          style: _extends({}, styles$1.Wrapper, {
            color: hovering ? theme.menuTextHighlightColor : '',
            opacity: menuItem.enabled ? '1' : '0.3',
            backgroundColor: hovering ? theme.menuHighlightColor : ''
          }),
          onMouseEnter: this.handleMouseEnter,
          onMouseLeave: this.handleMouseLeave,
          onClick: this.handleClick
        },
        React.createElement(
          'div',
          {
            className: css$3.StatusIcon,
            style: {
              color: hovering ? theme.menuTextHighlightColor : theme.accentStatusIcon ? theme.menuHighlightColor : theme.menuActiveTextColor
            }
          },
          statusIcon
        ),
        React.createElement(
          'span',
          { style: styles$1.Label },
          menuItem.label
        ),
        React.createElement(
          'span',
          {
            style: _extends({}, styles$1.Accelerator, {
              color: hovering ? theme.menuTextHighlightColor : theme.menuAcceleratorColor
            })
          },
          menuItem.accelerator
        ),
        isSubMenu && React.createElement(
          'div',
          {
            className: css$3.SubMenuArrow
          },
          arrow
        ),
        isSubMenu && this.state.hovering && children
      );
    }
  }]);
  return MenuItem;
}(Component);

MenuItem.propTypes = {
  menuItem: PropTypes.shape({
    label: PropTypes.string,
    enabled: PropTypes.bool,
    checked: PropTypes.bool,
    visible: PropTypes.bool,
    type: PropTypes.oneOf(['normal', 'separator', 'submenu', 'checkbox', 'radio']),
    click: PropTypes.func
  }),
  children: PropTypes.node,
  indx: PropTypes.number,
  changeCheckState: PropTypes.func
};

MenuItem.defaultProps = {
  menuItem: {
    id: '',
    enabled: true,
    label: '',
    checked: false,
    visible: true,
    type: 'normal',
    accelerator: '',
    position: ''
  },
  children: null,
  indx: 0,
  changeCheckState: function changeCheckState() {}
};

MenuItem.contextType = ThemeContext;

var getProperty = function getProperty(path, obj) {
  return path.reduce(function (xs, x) {
    return xs && xs[x] ? xs[x] : null;
  }, obj);
};

var reduxSet = function reduxSet(obj, path, val) {
  var _path = toArray(path),
      prop = _path[0],
      restPath = _path.slice(1);

  if (typeof prop === 'undefined') {
    if (!isEqual(obj, val)) {
      return val;
    }
    return obj;
  }
  var before = void 0;
  if (prop in obj) {
    before = obj[prop];
  } else {
    before = {};
  }
  var after = reduxSet(before, restPath, val);
  if (after !== before) {
    var result = void 0;
    if (Array.isArray(obj)) {
      result = obj.slice();
      result[prop] = after;
    } else {
      result = _extends({}, obj, defineProperty({}, prop, after));
    }
    return result;
  }
  return obj;
};

var defaultMenuItem = {
  id: '',
  enabled: true,
  label: '',
  checked: false,
  visible: true,
  type: 'normal',
  accelerator: '',
  position: '',
  submenu: [],
  click: function click() {}
};

var darkTheme$1 = {
  /* Title */
  barTheme: 'dark', // light, dark
  barHeight: '22px', // Change this value if you set 'titleBarStyle' to 'hiddenInset'
  winBarHeight: '28px',
  barColor: '#fff',
  barTitleColor: 'inherit',
  barBackgroundColor: '#24292e',
  barShowBorder: false,
  barBorderBottom: '1px solid #000',
  // should the icon be shown in the center of the toolbar on Mac/Linux apps alongside the app or title property
  showIconDarLin: true,

  /* Menu */
  menuStyle: 'horizontal', // horizontal, vertical
  menuDimItems: true,
  menuDimOpacity: 0.6,
  menuDisabledOpacity: 0.3,
  menuWidth: 240,
  menuBackgroundColor: '#fff',
  menuItemTextColor: '#fff',
  menuItemHoverBackground: 'rgba(255,255,255,0.3)',
  menuActiveTextColor: '#24292e',
  menuTextHighlightColor: '#fff',
  menuHighlightColor: '#0372ef',
  accentStatusIcon: false,
  menuSubLabelHeaders: true,
  menuSubLabelColor: '#6a737d',
  menuAcceleratorColor: '#6a737d',
  menuShowBoxShadow: true,
  menuBoxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',
  /* Menu Overlay */
  menuOverlayBackground: 'black',
  menuOverlayOpacity: 0.4,
  menuSeparatorColor: '#e1e4e8',

  /* WindowControls */
  windowControlsColor: '#fff',
  windowCloseHover: '#fff',
  windowCloseBackground: '#e81123',
  windowCloseActive: '#bf0f1d',
  windowDefaultBackground: 'rgba(255,255,255,0.3)',
  windowDefaultActive: 'rgba(255,255,255,0.2)'
};

var lightTheme$1 = _extends({}, darkTheme$1, {
  /* Title */
  barTheme: 'light',
  barColor: '#24292e',
  barBackgroundColor: '#e8e8e8',
  barBorderBottom: '1px solid #d3d4d5',

  /* Menu */
  menuItemTextColor: '#24292e',
  menuItemHoverBackground: 'rgba(0, 0, 0, 0.1)',

  /* WindowControls */
  windowControlsColor: '#000',
  windowDefaultBackground: 'rgba(0, 0, 0, 0.1)',
  windowDefaultActive: 'rgba(0, 0, 0, 0.2)'
});

var SubMenuLabelStyle = {
  height: '20px',
  lineHeight: '20px',
  margin: '0px 10px',
  fontWeight: 'bold',
  overflow: 'hidden',
  textOverflow: 'ellipsis',
  whiteSpace: 'nowrap',
  direction: 'rtl',
  fontSize: '1em',
  textAlign: 'left'
};

var styles$2 = {
  SubMenuWrapper: {
    position: 'absolute',
    width: '100%',
    padding: '5px 0px'
  }
};

var SubMenu = function (_Component) {
  inherits(SubMenu, _Component);

  function SubMenu(props) {
    classCallCheck(this, SubMenu);

    var _this = possibleConstructorReturn(this, (SubMenu.__proto__ || Object.getPrototypeOf(SubMenu)).call(this, props));

    _this.generateMenu = _this.generateMenu.bind(_this);
    return _this;
  }

  createClass(SubMenu, [{
    key: 'generateMenu',
    value: function generateMenu() {
      var _this2 = this;

      var menu = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var theme = this.context;
      return menu.map(function (menuItem, i) {
        if (menuItem.submenu) {
          // create submenu item
          var windowWidth = window.innerWidth;
          var renderSide = 'right';
          var right = _this2.props.right + theme.menuWidth;

          // Render menu to the left if the right side of the
          // current menu is greater than the current window width
          if (right > windowWidth) {
            if (theme.menuWidth < _this2.props.right - theme.menuWidth) {
              renderSide = 'left';
              right = _this2.props.right - theme.menuWidth;
            } else {
              var leftDiff = _this2.props.right - theme.menuWidth;
            }
          }
          return React.createElement(SubMenu, {
            key: '' + i + menuItem.label,
            level: _this2.props.level + 1,
            right: right,
            renderSide: renderSide,
            changeCheckState: _this2.props.changeCheckState,
            menuItem: _extends({}, defaultMenuItem, menuItem, { type: 'submenu' }),
            path: [].concat(toConsumableArray(_this2.props.path), [i, 'submenu'])
          });
        }

        return React.createElement(MenuItem, {
          key: '' + i + menuItem.label,
          changeCheckState: _this2.props.changeCheckState,
          menuItem: _extends({}, defaultMenuItem, menuItem),
          indx: i,
          path: [].concat(toConsumableArray(_this2.props.path))
        });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          menuItem = _props.menuItem,
          level = _props.level,
          renderSide = _props.renderSide;


      var theme = this.context;

      return React.createElement(
        MenuItem,
        {
          menuItem: _extends({}, defaultMenuItem, menuItem)
        },
        React.createElement(
          'div',
          {
            style: _extends({}, styles$2.SubMenuWrapper, {
              top: theme.menuSubLabelHeaders ? '-25px' : '-5px',
              left: renderSide === 'left' ? '-100%' : '100%',
              maxWidth: theme.menuWidth,
              backgroundColor: theme.menuBackgroundColor,
              color: theme.menuActiveTextColor,
              zIndex: level + 8,
              boxShadow: theme.menuShowBoxShadow ? theme.menuBoxShadow : ''
            })
          },
          theme.menuSubLabelHeaders && React.createElement(
            'div',
            {
              style: _extends({}, SubMenuLabelStyle, {
                color: theme.menuSubLabelColor
              })
            },
            menuItem.label
          ),
          this.generateMenu(menuItem.submenu)
        )
      );
    }
  }]);
  return SubMenu;
}(Component);

SubMenu.propTypes = {
  menuItem: PropTypes.object,
  level: PropTypes.number,
  renderSide: PropTypes.string,
  changeCheckState: PropTypes.func
};

SubMenu.defaultProps = {
  menuItem: {},
  level: 1,
  renderSide: 'right',
  changeCheckState: function changeCheckState() {}
};

SubMenu.contextType = ThemeContext;

var css$4 = ".styles_MenuListOverlay__1kChh {\n  height: 100%;\n  overflow: hidden;\n}\n\n.styles_MenuListOverlay__1kChh:focus {\n  outline: none;\n  border: none;\n  box-shadow: none;\n}";
var css$5 = { "MenuListOverlay": "styles_MenuListOverlay__1kChh" };
styleInject(css$4);

var styles$3 = {
  Wrapper: {
    zIndex: 8,
    position: 'absolute',
    width: '100%',
    overflow: 'hidden',
    left: 0
  },
  FoldOut: {
    background: 'transparent',
    pointerEvents: 'none',
    position: 'absolute',
    top: 0
  },
  MenuPane: {
    pointerEvents: 'all'
  },
  MenuFoldOut: {
    paddingTop: 5,
    paddingBottom: 5
  }
};

var MenuList = function (_Component) {
  inherits(MenuList, _Component);

  function MenuList(props) {
    classCallCheck(this, MenuList);

    var _this = possibleConstructorReturn(this, (MenuList.__proto__ || Object.getPrototypeOf(MenuList)).call(this, props));

    _this.generateMenu = _this.generateMenu.bind(_this);
    return _this;
  }

  createClass(MenuList, [{
    key: 'generateMenu',
    value: function generateMenu() {
      var _this2 = this;

      var menu = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var theme = this.context;
      return menu.map(function (menuItem, i) {
        if (menuItem.submenu || menuItem.type && menuItem.type.toLowerCase() === 'submenu') {
          var menuWidth = _this2.props.rect.left + theme.menuWidth;
          var windowWidth = window.innerWidth;
          var renderSide = 'right';
          var right = menuWidth + theme.menuWidth;

          // Render menu to the left if the right side of the
          // current menu is greater than the current window width
          if (right > windowWidth && theme.menuWidth < _this2.props.rect.left) {
            renderSide = 'left';
            right = menuWidth - theme.menuWidth;
          }

          return React.createElement(SubMenu, {
            key: '' + i + menuItem.label,
            level: 1,
            right: right,
            renderSide: renderSide,
            changeCheckState: _this2.props.changeCheckState,
            menuItem: _extends({}, defaultMenuItem, menuItem, { type: 'submenu' }),
            path: _this2.props.vertical ? [].concat(toConsumableArray(_this2.props.path), [i, 'submenu']) : [].concat(toConsumableArray(_this2.props.path), ['submenu', i, 'submenu'])
          });
        }
        return React.createElement(MenuItem, {
          key: '' + i + menuItem.label,
          menuItem: _extends({}, defaultMenuItem, menuItem),
          changeCheckState: _this2.props.changeCheckState,
          indx: i,
          path: _this2.props.vertical ? [].concat(toConsumableArray(_this2.props.path)) : [].concat(toConsumableArray(_this2.props.path), ['submenu'])
        });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          submenu = _props.submenu,
          rect = _props.rect;


      var theme = this.context;

      return React.createElement(
        'div',
        {
          style: _extends({}, styles$3.Wrapper, {
            height: 'calc(100% - ' + rect.bottom + 'px)',
            top: rect.bottom + 'px'
          })
        },
        React.createElement('div', {
          className: css$5.MenuListOverlay,
          style: {
            background: theme.menuOverlayBackground,
            opacity: theme.menuOverlayOpacity
          },
          tabIndex: '-1'
        }),
        React.createElement(
          'div',
          {
            style: _extends({}, styles$3.FoldOut, {
              marginLeft: rect.left,
              maxWidth: 'calc(100% - ' + rect.left + 'px)',
              color: theme.menuActiveTextColor
            })
          },
          React.createElement(
            'div',
            {
              style: _extends({}, styles$3.MenuFoldOut, {
                background: theme.menuBackgroundColor,
                boxShadow: theme.showBoxShadow ? theme.menuBoxShadow : ''
              })
            },
            React.createElement(
              'div',
              {
                style: _extends({}, styles$3.MenuPane, {
                  width: theme.menuWidth
                })
              },
              theme.menuStyle === 'vertical' && theme.menuSubLabelHeaders && React.createElement(
                'div',
                {
                  style: _extends({}, SubMenuLabelStyle, {
                    color: theme.menuSubLabelColor
                  }),
                  key: 'main-menu-sublabel'
                },
                'Menu'
              ),
              this.generateMenu(submenu)
            )
          )
        )
      );
    }
  }]);
  return MenuList;
}(Component);

MenuList.propTypes = {
  submenu: PropTypes.array,
  path: PropTypes.array,
  rect: PropTypes.shape({
    height: PropTypes.number,
    width: PropTypes.number,
    x: PropTypes.number,
    y: PropTypes.number
  }).isRequired,
  changeCheckState: PropTypes.func
};

MenuList.defaultProps = {
  submenu: [],
  path: [],
  changeCheckState: function changeCheckState() {}
};

MenuList.contextType = ThemeContext;

var topologicalSort = function topologicalSort(original, graph) {
  // Sort items topologically using a depth-first approach
  var sorted = [];
  var visited = new Set();

  var visit = function visit(mark) {
    // if item visited return
    if (visited.has(mark)) return;
    // add item to list of visited nodes
    visited.add(mark);
    // get edges from graph for visited id
    var edges = graph.get(mark);
    if (edges != null) {
      // visit each edge
      edges.forEach(visit);
    }
    sorted.push(mark);
  };

  original.forEach(visit);
  return sorted;
};

var areValidTemplateItems = function areValidTemplateItems(template) {
  // validate the menu attributes
  return template.every(function (item) {
    if (item === null || (typeof item === 'undefined' ? 'undefined' : _typeof(item)) !== 'object') {
      return false;
    }
    return item.hasOwnProperty('label') || item.type === 'separator';
  });
};

var addEdge = function addEdge(graph, from, to) {
  if (!graph.has(from)) {
    // create edge list from
    graph.set(from, []);
  }
  // add to edge list from -> to
  graph.get(from).push(to);
};

var sortMenuItems = function sortMenuItems(menu) {
  var original = menu.map(function (item, i) {
    return i;
  });
  var graph = new Map();
  var idToIndex = new Map(menu.map(function (item, i) {
    return [item.id, i];
  }));
  // add graph edges to perform topological sort
  menu.forEach(function (item, i) {
    if (item.before) {
      // get index from item before id
      var to = idToIndex.get(item.before);
      if (to != null) {
        // add edge pointing from item before -> to current item
        addEdge(graph, to, i);
      }
    }
    if (item.after) {
      // get index from item after id
      var _to = idToIndex.get(item.after);
      if (_to != null) {
        // add edge from current item pointing -> to item after
        addEdge(graph, i, _to);
      }
    }
  });
  // sort edges
  var sortedOrder = topologicalSort(original, graph);
  // return sorted menu items
  return sortedOrder.map(function (i) {
    return menu[i];
  });
};

var sortMenu = function sortMenu(menu) {
  // sort menu and all submenus
  var sorted = sortMenuItems(menu);
  for (var id in sorted) {
    var item = sorted[id];
    if (Array.isArray(item.submenu)) {
      // sort submenus
      item.submenu = sortMenu(item.submenu);
    }
  }
  return sorted;
};

var buildMenu = function buildMenu(menu) {
  if (!Array.isArray(menu)) {
    throw new TypeError('Menu must be an array');
  }
  if (!areValidTemplateItems(menu)) {
    throw new TypeError('MenuItem must have at least one of label, role or type');
  }
  return sortMenu(menu);
};

var menuIcon = React.createElement(
  'svg',
  { version: '1.1', width: '24px', height: '24px', viewBox: '0 0 32 32' },
  React.createElement('path', { d: 'M 4 7 L 4 9 L 28 9 L 28 7 Z M 4 15 L 4 17 L 28 17 L 28 15 Z M 4 23 L 4 25 L 28 25 L 28 23 Z ' })
);

var styles$4 = {
  Wrapper: {
    display: 'flex',
    WebkitAppRegion: 'no-drag',
    maxWidth: 'calc(100% - 163px)'
  }
};

var MenuBar = function (_Component) {
  inherits(MenuBar, _Component);

  function MenuBar(props) {
    classCallCheck(this, MenuBar);

    var _this = possibleConstructorReturn(this, (MenuBar.__proto__ || Object.getPrototypeOf(MenuBar)).call(this, props));

    _this.onMenuButtonMouseOver = function (i) {
      if (_this.state.clicked) {
        _this.setState({
          focusing: i
        });
      }
    };

    _this.onTouchStart = function (i) {
      if (i !== _this.state.focusing && _this.state.clicked) {
        _this.lock = true;
      }
    };

    _this.onMouseMove = function (i) {
      if (i === _this.state.focusing) return;
      _this.setState({
        focusing: i
      });
    };

    _this.onMenuButtonClick = function (index) {
      if (_this.lock) {
        _this.lock = false;
        return;
      }
      _this.setState({
        clicked: !(_this.state.focusing === index && _this.state.clicked),
        hovering: !(_this.state.focusing === index && _this.state.clicked) ? _this.state.hovering : -1
      });
    };

    _this.setMenuRef = function (ref, i) {
      if (_this.menuItems) {
        _this.menuItems[i] = ref;
      } else {
        _this.menuItems = defineProperty({}, i, ref);
      }
    };

    _this.changeCheckState = function (path, itemIndx, checked) {
      var isRadio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!isRadio) {
        // change checked state
        _this.setState(reduxSet(_this.state, [].concat(toConsumableArray(path), [itemIndx, 'checked']), checked));
      } else {
        var newState = _extends({}, _this.state);
        getProperty(path, _this.state).forEach(function (menuItem, indx) {
          if (menuItem.type === 'radio') {
            newState = reduxSet(newState, [].concat(toConsumableArray(path), [indx, 'checked']), indx === itemIndx);
          }
        });
        _this.setState(newState);
      }
    };

    _this.generateHorizontalMenu = function () {
      var menuObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return menuObj.map(function (menuItem, i) {
        return React.createElement(
          MenuButton,
          {
            key: '' + menuItem.label,
            onMouseEnter: function onMouseEnter() {
              if (menuItem.enabled === false) return;
              _this.setState({
                hovering: i
              });
            },
            onMouseLeave: function onMouseLeave() {
              if (menuItem.enabled === false) return;
              _this.setState({
                hovering: -1
              });
            },
            onMouseOver: function onMouseOver() {
              if (menuItem.enabled === false) return;
              _this.onMenuButtonMouseOver(i);
            },
            onMouseMove: function onMouseMove() {
              if (menuItem.enabled === false) return;
              _this.onMouseMove(i);
            },
            onTouchStart: function onTouchStart() {
              if (menuItem.enabled === false) return;
              _this.onTouchStart(i);
            },
            onClick: function onClick() {
              if (menuItem.enabled === false) return;
              _this.onMenuButtonClick(i);
            },
            onFocus: function onFocus() {
              // idk - linting says it needs it? it has no purpose for me
            },
            rectRef: function rectRef(ref) {
              return _this.setMenuRef(ref, i);
            },
            hovering: i === _this.state.hovering,
            open: _this.state.clicked && i === _this.state.focusing,
            closed: !_this.state.clicked || i !== _this.state.focusing,
            enabled: menuItem.enabled,
            label: menuItem.label
          },
          _this.state.clicked && i === _this.state.focusing && React.createElement(MenuList, {
            changeCheckState: _this.changeCheckState,
            rect: _this.menuItems[i].getBoundingClientRect(),
            submenu: menuItem.submenu,
            mainIndex: i,
            path: ['menu', i]
          })
        );
      });
    };

    _this.generateVerticalMenu = function () {
      var menuList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return React.createElement(
        MenuButton,
        {
          onMouseEnter: function onMouseEnter() {
            _this.setState({
              hovering: 0
            });
          },
          onMouseLeave: function onMouseLeave() {
            _this.setState({
              hovering: -1
            });
          },
          onMouseOver: function onMouseOver() {
            _this.onMenuButtonMouseOver(0);
          },
          onMouseMove: function onMouseMove() {
            _this.onMouseMove(0);
          },
          onTouchStart: function onTouchStart() {
            _this.onTouchStart(0);
          },
          onClick: function onClick() {
            _this.onMenuButtonClick(0);
          },
          onFocus: function onFocus() {
            // idk - linting says it needs it? it has no purpose for me
          },
          rectRef: function rectRef(ref) {
            return _this.setMenuRef(ref, 0);
          },
          hovering: _this.state.hovering === 0,
          open: _this.state.clicked && _this.state.focusing === 0,
          closed: !_this.state.clicked || _this.state.focusing !== 0,
          label: menuIcon,
          enabled: true
        },
        _this.state.clicked && _this.state.focusing === 0 && React.createElement(MenuList, {
          changeCheckState: _this.changeCheckState,
          rect: _this.menuItems[0].getBoundingClientRect(),
          submenu: menuList,
          path: ['menu'],
          vertical: true
        })
      );
    };

    _this.state = {
      hovering: -1,
      focusing: 0,
      clicked: false,
      menu: buildMenu(props.menu)
    };
    return _this;
  }

  createClass(MenuBar, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.menu !== this.state.menu) {
        this.setState({
          menu: buildMenu(nextProps.menu)
        });
      }
    }

    // if hovering over another button while menu is clicked; change focus


    // lock set to true to keep menu panes open


    // if moving over a different menu button - select that menu button


    // when a menu button is clicked


    // we need the rect's bounds for the child menu pane


    // path: to current submenu
    // checked: new state

  }, {
    key: 'render',
    value: function render() {
      var theme = this.context;
      var color = theme.menuItemTextColor || theme.barColor;
      return React.createElement(
        'div',
        { style: _extends({}, styles$4.Wrapper, { color: color }) },
        theme.menuStyle === 'horizontal' ? this.generateHorizontalMenu(this.state.menu) : this.generateVerticalMenu(this.state.menu)
      );
    }
  }]);
  return MenuBar;
}(Component);

MenuBar.propTypes = {
  menu: PropTypes.array
};

MenuBar.defaultProps = {
  menu: []
};

MenuBar.contextType = ThemeContext;

var styles$5 = {
  Bar: {
    flexGrow: 0,
    flexShrink: 0,
    display: 'flex',
    flexDirection: 'row',
    fontSize: '12px',
    width: '100%',
    WebkitAppRegion: 'drag',
    userSelect: 'none',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", Arial, sans-serif'
  }
};

var currentWindow = electron.remote.getCurrentWindow();

var Bar = function (_React$Component) {
  inherits(Bar, _React$Component);

  function Bar(props) {
    classCallCheck(this, Bar);

    var _this = possibleConstructorReturn(this, (Bar.__proto__ || Object.getPrototypeOf(Bar)).call(this, props));

    _this.handleDoubleClick = _this.handleDoubleClick.bind(_this);
    return _this;
  }

  createClass(Bar, [{
    key: 'handleDoubleClick',
    value: function handleDoubleClick(e) {
      var isWin = this.props.isWin;

      if (!isWin) {
        var bounds = electron.screen.getPrimaryDisplay().workArea;
        currentWindow.setBounds(bounds, true);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var props = this.props;
      var theme = this.context;
      var height = props.isWin ? theme.winBarHeight : theme.barHeight;
      var backgroundColor = theme.barBackgroundColor;
      var color = theme.barColor;
      var borderBottom = theme.barShowBorder ? theme.barBorderBottom : '';

      return React.createElement(
        'div',
        {
          style: _extends({}, styles$5.Bar, { height: height, backgroundColor: backgroundColor, color: color, borderBottom: borderBottom }),
          onDoubleClick: this.handleDoubleClick
        },
        props.children
      );
    }
  }]);
  return Bar;
}(React.Component);

Bar.contextType = ThemeContext;

Bar.defaultProps = {
  isWin: false
};

var styles$6 = {
  Title: {
    margin: '0px 6px 0px 0px',
    textAlign: 'center',
    display: 'flex',
    whiteSpace: 'nowrap',
    justifyContent: 'center',
    alignContent: 'center',
    alignItems: 'center',
    flexDirection: 'row',
    WebkitAppRegion: 'drag'
  }
};

var Title = function (_React$Component) {
  inherits(Title, _React$Component);

  function Title() {
    classCallCheck(this, Title);
    return possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).apply(this, arguments));
  }

  createClass(Title, [{
    key: 'render',
    value: function render() {
      var props = this.props;
      var theme = this.context;
      var lineHeight = props.isWin ? theme.winBarHeight : theme.barHeight;
      var padding = props.isWin ? '0px 4px' : '0 70px';
      var flex = props.flex;
      var color = theme.barTitleColor;
      var fontFamily = theme.titleFontFamily;
      var fontWeight = theme.titleFontWeight;

      return React.createElement(
        'div',
        {
          style: _extends({}, styles$6.Title, { lineHeight: lineHeight, padding: padding, color: color, flex: flex, fontFamily: fontFamily, fontWeight: fontWeight })
        },
        props.children
      );
    }
  }]);
  return Title;
}(React.Component);

Title.contextType = ThemeContext;

var styles$7 = {
  ResizeHandle: {
    position: 'absolute',
    top: 0,
    left: 0,
    WebkitAppRegion: 'no-drag'
  },
  ResizeLeft: {
    width: '3px',
    height: '28px'
  },
  ResizeTop: {
    width: '100%',
    height: '3px'
  }
};

var ResizeHandle = function (_React$Component) {
  inherits(ResizeHandle, _React$Component);

  function ResizeHandle() {
    classCallCheck(this, ResizeHandle);
    return possibleConstructorReturn(this, (ResizeHandle.__proto__ || Object.getPrototypeOf(ResizeHandle)).apply(this, arguments));
  }

  createClass(ResizeHandle, [{
    key: 'render',
    value: function render() {
      return React.createElement('div', {
        style: _extends({}, styles$7.ResizeHandle, this.props.left ? styles$7.ResizeLeft : styles$7.ResizeTop)
      });
    }
  }]);
  return ResizeHandle;
}(React.Component);

ResizeHandle.defaultProps = {
  left: PropTypes.bool,
  top: PropTypes.bool
};

var styles$8 = {
  Icon: {
    height: '16px',
    width: '16px',
    margin: '6px'
  }
};

var Icon = function (_React$Component) {
  inherits(Icon, _React$Component);

  function Icon() {
    classCallCheck(this, Icon);
    return possibleConstructorReturn(this, (Icon.__proto__ || Object.getPrototypeOf(Icon)).apply(this, arguments));
  }

  createClass(Icon, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          src = _props.src,
          onIconClick = _props.onIconClick;


      return React.createElement('img', {
        src: src,
        alt: 'app-icon',
        onClick: onIconClick,
        style: styles$8.Icon
      });
    }
  }]);
  return Icon;
}(React.Component);

Icon.defaultProps = {
  src: PropTypes.string,
  onIconClick: PropTypes.func
};

var css$6 = ".styles_Button__3WaZS {\n  -webkit-app-region: no-drag;\n  display: inline-block;\n  position: relative;\n  width: 45px;\n  height: 100%;\n  padding: 0;\n  margin: 0;\n  overflow: hidden;\n  border: none;\n  box-shadow: none;\n  border-radius: 0;\n  background-color: transparent;\n  transition: background-color 0.25s ease;\n  opacity: 0.5;\n}\n\n.styles_Button__3WaZS svg {  \n  fill: currentColor;\n}\n\n.styles_Button__3WaZS:focus {\n  outline: none;\n}\n\n.styles_Button__3WaZS:hover {\n  opacity: 1;\n}\n\n.styles_Button__3WaZS:hover:active {\n  transition: none;\n  opacity: 1;\n}\n";
var styles$9 = { "Button": "styles_Button__3WaZS" };
styleInject(css$6);

var Button = function (_Component) {
  inherits(Button, _Component);

  function Button(props) {
    classCallCheck(this, Button);

    var _this = possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).call(this, props));

    _this.toggleHover = function () {
      _this.setState({
        hovering: !_this.state.hovering
      });
    };

    _this.toggleFocus = function () {
      _this.setState({
        focused: !_this.state.focused
      });
    };

    _this.state = {
      hovering: false,
      focused: false
    };
    return _this;
  }

  createClass(Button, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          ariaLabel = _props.ariaLabel,
          tabIndex = _props.tabIndex,
          disabled = _props.disabled,
          close = _props.close,
          onClick = _props.onClick;
      var _state = this.state,
          hovering = _state.hovering,
          focused = _state.focused;


      var backgroundColor = 'transparent';
      var opacity = 0.5;
      var transition = 'background-color 0.25s ease';
      var color = this.context.windowControlsColor;
      if (hovering) {
        opacity = 1;
        color = close ? this.context.windowCloseHover : color;
        backgroundColor = close ? this.context.windowCloseBackground : this.context.windowDefaultBackground;
      } else if (focused) {
        opacity = 1;
        color = close ? this.context.windowCloseHover : color;
        backgroundColor = close ? this.context.windowCloseActive : this.context.windowDefaultActive;
        transition = 'none';
      }

      return React.createElement(
        'button',
        {
          className: styles$9.Button,
          style: { backgroundColor: backgroundColor, opacity: opacity, transition: transition, color: color },
          onFocus: this.toggleFocus,
          onBlur: this.toggleFocus,
          onMouseEnter: this.toggleHover,
          onMouseLeave: this.toggleHover,
          onClick: onClick,
          'aria-label': ariaLabel,
          tabIndex: tabIndex,
          disabled: disabled
        },
        this.props.children
      );
    }
  }]);
  return Button;
}(Component);

Button.contextType = ThemeContext;

var currentWindow$1 = electron.remote.getCurrentWindow();

var styles$a = {
  Controls: {
    flexGrow: 0,
    flexShrink: 0,
    marginLeft: 'auto',
    height: '100%'
  }
};

var WindowControls = function (_Component) {
  inherits(WindowControls, _Component);

  function WindowControls(props) {
    classCallCheck(this, WindowControls);

    var _this = possibleConstructorReturn(this, (WindowControls.__proto__ || Object.getPrototypeOf(WindowControls)).call(this, props));

    _this.handleMaximize = function (max) {
      _this.setState({
        isMaximized: max
      });
    };

    _this.onMaximizeClicked = function () {
      if (currentWindow$1.isMaximizable()) {
        if (currentWindow$1.isMaximized()) {
          currentWindow$1.unmaximize();
        } else {
          currentWindow$1.maximize();
        }
      }
    };

    _this.state = {
      isMaximized: currentWindow$1.isMaximized()
    };
    return _this;
  }

  createClass(WindowControls, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      currentWindow$1.addListener('maximize', function () {
        return _this2.setState({ isMaximized: true });
      });
      currentWindow$1.addListener('unmaximize', function () {
        return _this2.setState({ isMaximized: false });
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      var _this3 = this;

      currentWindow$1.removeListener('maximize', function () {
        return _this3.setState({ isMaximized: true });
      });
      currentWindow$1.removeListener('unmaximize', function () {
        return _this3.setState({ isMaximized: false });
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          disableMaximize = _props.disableMaximize,
          disableMinimize = _props.disableMinimize;
      var isMaximized = this.state.isMaximized;


      return React.createElement(
        'div',
        { style: styles$a.Controls },
        React.createElement(
          Button,
          {
            key: 'min-button',
            ariaLabel: 'minimize',
            tabIndex: '-1',
            disabled: disableMinimize,
            onClick: function onClick() {
              return currentWindow$1.minimize();
            }
          },
          React.createElement(
            'svg',
            {
              version: '1.1',
              'aria-hidden': 'true',
              width: '10',
              height: '10'
            },
            React.createElement('path', {
              d: 'M 0,5 10,5 10,6 0,6 Z'
            })
          )
        ),
        React.createElement(
          Button,
          {
            key: 'max-button',
            ariaLabel: 'maximize',
            tabIndex: '-1',
            disabled: disableMaximize,
            onClick: this.onMaximizeClicked
          },
          isMaximized ? React.createElement(
            'svg',
            {
              version: '1.1',
              'aria-hidden': 'true',
              width: '10',
              height: '10'
            },
            React.createElement('path', {
              d: 'm 2,1e-5 0,2 -2,0 0,8 8,0 0,-2 2,0 0,-8 z m 1,1 6,0 0,6 -1,0 0,-5 -5,0 z m -2,2 6,0 0,6 -6,0 z'
            })
          ) : React.createElement(
            'svg',
            {
              version: '1.1',
              'aria-hidden': 'true',
              width: '10',
              height: '10'
            },
            React.createElement('path', {
              d: 'M 0,0 0,10 10,10 10,0 Z M 1,1 9,1 9,9 1,9 Z'
            })
          )
        ),
        React.createElement(
          Button,
          {
            key: 'close-button',
            'aria-label': 'close',
            tabIndex: '-1',
            onClick: function onClick() {
              return currentWindow$1.close();
            },
            close: true
          },
          React.createElement(
            'svg',
            {
              'aria-hidden': 'true',
              version: '1.1',
              width: '10',
              height: '10'
            },
            React.createElement('path', { d: 'M 0,0 0,0.7 4.3,5 0,9.3 0,10 0.7,10 5,5.7 9.3,10 10,10 10,9.3 5.7,5 10,0.7 10,0 9.3,0 5,4.3 0.7,0 Z' })
          )
        )
      );
    }
  }]);
  return WindowControls;
}(Component);


WindowControls.propTypes = {
  disableMinimize: PropTypes.bool,
  disableMaximize: PropTypes.bool
};

WindowControls.defaultProps = {
  disableMinimize: false,
  disableMaximize: false
};

var TitleBar = function (_Component) {
  inherits(TitleBar, _Component);

  function TitleBar() {
    var _ref;

    var _temp, _this, _ret;

    classCallCheck(this, TitleBar);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TitleBar.__proto__ || Object.getPrototypeOf(TitleBar)).call.apply(_ref, [this].concat(args))), _this), _this.generatePlatformChildren = function (_ref2) {
      var icon = _ref2.icon,
          app = _ref2.app,
          title = _ref2.title,
          platform = _ref2.platform,
          menu = _ref2.menu,
          children = _ref2.children,
          currentTheme = _ref2.currentTheme,
          onIconClick = _ref2.onIconClick,
          onTitleClick = _ref2.onTitleClick,
          onCloseClick = _ref2.onCloseClick,
          onMinimizeClick = _ref2.onMinimizeClick,
          onMaximizeClick = _ref2.onMaximizeClick,
          disableMaximize = _ref2.disableMaximize,
          disableMinimize = _ref2.disableMinimize,
          onBarDoubleClick = _ref2.onBarDoubleClick;

      switch (platform) {
        case 'win32':
          // win32
          return React.createElement(
            Bar,
            { isWin: true },
            React.createElement(ResizeHandle, { top: true }),
            React.createElement(ResizeHandle, { left: true }),
            currentTheme.menuStyle === 'vertical' && React.createElement(MenuBar, {
              menu: menu
            }),
            icon && React.createElement(Icon, {
              src: icon,
              onClick: onIconClick
            }),
            app && React.createElement(
              Title,
              {
                onClick: onTitleClick,
                isWin: true
              },
              app
            ),
            currentTheme.menuStyle === 'horizontal' && React.createElement(MenuBar, {
              menu: menu
            }),
            children,
            React.createElement(WindowControls, {
              disableMinimize: disableMinimize,
              disableMaximize: disableMaximize,
              onCloseClick: onCloseClick,
              onMinimizeClick: onMinimizeClick,
              onMaximizeClick: onMaximizeClick
            })
          );
        default:
          return React.createElement(
            Bar,
            {
              onDoubleClick: onBarDoubleClick
            },
            React.createElement(ResizeHandle, { top: true }),
            React.createElement(ResizeHandle, { left: true }),
            (title || app) && React.createElement(
              Title,
              {
                onClick: onTitleClick,
                flex: 1
              },
              icon && currentTheme.showIconDarLin && React.createElement(Icon, {
                src: icon,
                onClick: onIconClick
              }),
              title || app
            )
          );
      }
    }, _temp), possibleConstructorReturn(_this, _ret);
  }

  createClass(TitleBar, [{
    key: 'render',
    value: function render() {
      var _props = this.props,
          theme = _props.theme,
          platform = _props.platform;


      var currentTheme = _extends({}, theme.barTheme === 'light' ? lightTheme : darkTheme, theme);

      return React.createElement(
        ThemeProvider,
        { value: currentTheme },
        this.generatePlatformChildren(_extends({}, this.props, {
          currentTheme: currentTheme,
          platform: platform === 'default' ? os.platform() : platform || os.platform()
        }))
      );
    }
  }]);
  return TitleBar;
}(Component);

TitleBar.propTypes = {
  children: PropTypes.node,
  icon: PropTypes.string,
  title: PropTypes.string,
  platform: PropTypes.string,
  theme: PropTypes.object,
  /* Menu */
  menu: PropTypes.array,
  /* Window */
  disableMinimize: PropTypes.bool,
  disableMaximize: PropTypes.bool,
  /* Functions */
  onIconClick: PropTypes.func,
  onTitleClick: PropTypes.func,
  onCloseClick: PropTypes.func,
  onMinimizeClick: PropTypes.func,
  onMaximizeClick: PropTypes.func
};

TitleBar.defaultProps = {
  children: null,

  /* Main */
  icon: '',
  name: '',
  title: '',
  platform: '',
  theme: {},

  /* WindowControls */
  disableMinimize: false,
  disableMaximize: false,

  /* Menu */
  menu: [],

  /* Click Listeners */
  onIconClick: function onIconClick() {},
  onTitleClick: function onTitleClick() {},
  onCloseClick: function onCloseClick() {},
  onMinimizeClick: function onMinimizeClick() {},
  onMaximizeClick: function onMaximizeClick() {},
  onBarDoubleClick: function onBarDoubleClick() {}
};

export default TitleBar;
//# sourceMappingURL=index.es.js.map
